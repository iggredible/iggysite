(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{254:function(e,t,n){"use strict";n.r(t);var a=n(37),r=Object(a.a)({},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[n("img",{attrs:{src:"https://thepracticaldev.s3.amazonaws.com/i/v2eqqpibor579mb9jw5a.jpg",alt:"HTML Image on Screen"}})]),e._v(" "),n("h1",{attrs:{id:"intro"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#intro","aria-hidden":"true"}},[e._v("#")]),e._v(" Intro")]),e._v(" "),n("p",[e._v("Imagine you are building your house. One day you want to add a new kitchen island - so you rebuild the house from scratch. Then you want to repaint the house, so you again rebuild the whole house. Then it's time to change your window panes into, so you rebuild it from scratch...again. Unless you are Fix-It Felix, this is not the way to make house updates.")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://media.giphy.com/media/MtIPR6C5okdt6/giphy.gif",alt:"fix-it-felix"}})]),e._v(" "),n("p",[e._v("Instead, you should have a blueprint of the house. To add a kitchen island, you find which area will be affected on the blueprint and only rebuild that area. If you want to repaint, calculate the wall perimeter area from blueprint, move out all the stuff next to the wall (just don't do "),n("a",{attrs:{href:"https://www.youtube.com/watch?v=EiZoSuNej5U",target:"_blank",rel:"noopener noreferrer"}},[e._v("this"),n("OutboundLink")],1),e._v(" please), and start painting. If you want to change your window panes, locate all windows from blueprint and replace them.")]),e._v(" "),n("p",[e._v("The same can be said about DOM. Think of HTML DOM as a house and virtual DOM as blueprint of the house. We should use virtual DOM to help us make changes to our DOM.\nThis post is largely inspired by Jason Yu's "),n("a",{attrs:{href:"https://www.youtube.com/watch?v=85gJMUEcnkc",target:"_blank",rel:"noopener noreferrer"}},[e._v("Building a Simple Virtual DOM from Scratch"),n("OutboundLink")],1),e._v(" video (I am not affiliated with him, but I found his stuff super helpful. You should check him out!). This is a shortened and simplified version. My hope is that readers who are new with virtual DOM will gain better understanding what virtual DOM is.")]),e._v(" "),n("h1",{attrs:{id:"layout-of-the-land"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#layout-of-the-land","aria-hidden":"true"}},[e._v("#")]),e._v(" Layout of the land")]),e._v(" "),n("p",[e._v("The code can be found in "),n("a",{attrs:{href:"https://github.com/iggredible/simple-vdom-demo",target:"_blank",rel:"noopener noreferrer"}},[e._v("this github repo"),n("OutboundLink")],1),e._v(". This post is divided into 6 steps:")]),e._v(" "),n("ol",[n("li",[e._v("Setup")]),e._v(" "),n("li",[e._v("Creating virtual DOM")]),e._v(" "),n("li",[e._v("Rendering DOM nodes")]),e._v(" "),n("li",[e._v("Mounting into HTML page")]),e._v(" "),n("li",[e._v("Updating the DOM the inefficient way")]),e._v(" "),n("li",[e._v("Updating the DOM the efficient way")])]),e._v(" "),n("p",[e._v("Let's get started!")]),e._v(" "),n("h1",{attrs:{id:"setup"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#setup","aria-hidden":"true"}},[e._v("#")]),e._v(" Setup")]),e._v(" "),n("p",[e._v("Before we even begin, make sure we have "),n("a",{attrs:{href:"https://nodejs.org/en/download/",target:"_blank",rel:"noopener noreferrer"}},[e._v("latest node"),n("OutboundLink")],1),e._v(" ready. Create a folder and cd into it, start an NPM project ("),n("code",[e._v("npm init -y")]),e._v("). Create "),n("code",[e._v("index.html")]),e._v(" and "),n("code",[e._v("vdom.js")]),e._v(" in root directory. For quick bundling, we'll use "),n("a",{attrs:{href:"https://github.com/parcel-bundler/parcel",target:"_blank",rel:"noopener noreferrer"}},[n("code",[e._v("parcel-bundler")]),n("OutboundLink")],1),e._v(" so run "),n("code",[e._v("npm install parcel-bundler")]),e._v('. I also like having "start": "parcel index.html" in package.json.')]),e._v(" "),n("p",[e._v("My "),n("code",[e._v("index.html")]),e._v(" looks like this:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<!DOCTYPE html>\n<html lang="en">\n  <head> \n    <meta charset="UTF-8"> \n    <title>Basic Virtual Dom Demo</title>\n  </head>\n  <body> \n    <h1>Virtual Dom Demo</h1> \n    <div id="app"></div> \n    <script src="./vdom.js"><\/script>\n  </body>\n</html>\n')])])]),n("p",[e._v("Just make sure to import "),n("code",[e._v("vdom.js")]),e._v(" and have something like "),n("code",[e._v('<div id="app"></div>')]),e._v(" to mount our DOM later.")]),e._v(" "),n("h1",{attrs:{id:"creating-virtual-dom"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#creating-virtual-dom","aria-hidden":"true"}},[e._v("#")]),e._v(" Creating virtual DOM")]),e._v(" "),n("p",[e._v("Virtual DOM is nothing but a "),n("em",[e._v("javascript object that represents DOM nodes")]),e._v(". As mentioned earlier, virtual DOM to DOM is what a blueprint is to a house. A house is physical, expensive to update, while a blueprint is just a piece of paper and much easier to update.")]),e._v(" "),n("p",[e._v("This is what our virtual DOM looks like:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('const vAppStructure = num => {\n  return {\n    tagName: "ul",\n    text: "",\n    attrs: { class: "parent-class", id: `parent-id-${num}` },\n    children: [\n      {\n        tagName: "li",\n        attrs: "",\n        text: "list 1",\n        attrs: { class: "child-class" },\n        children: []\n      },\n      {\n        tagName: "li",\n        attrs: "",\n        text: "list 2",\n        attrs: { class: "child-class" },\n        children: [{ tagName: "input", attrs: "", text: "", children: [] }]\n      }\n    ]\n  };\n};\n')])])]),n("p",[e._v("Observations:")]),e._v(" "),n("ol",[n("li",[e._v("Virtual DOM is a JS object.")]),e._v(" "),n("li",[e._v('In this example, it is a function because in the future it needs to be updated. Virtual DOM does not have to be a function at all, it can be a plain JS object (technically you can just do const myVDom = {name: "div"} and that will counts as a VDOM!)')]),e._v(" "),n("li",[e._v("The structure represent a "),n("code",[e._v("<ul>")]),e._v(" element with 2 "),n("code",[e._v("<li>")]),e._v(" children.")]),e._v(" "),n("li",[e._v("The 2nd child has another child, an input. It will be used in step 4 later.")])]),e._v(" "),n("h1",{attrs:{id:"rendering-dom-nodes"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#rendering-dom-nodes","aria-hidden":"true"}},[e._v("#")]),e._v(" Rendering DOM Nodes")]),e._v(" "),n("p",[e._v("We have a virtual DOM structure now. We should render it into DOM nodes. The main Javascript APIs needed in this post are: "),n("code",[e._v("document.createElement")]),e._v(", "),n("code",[e._v("Element.setAttribute")]),e._v(", "),n("code",[e._v("document.createTextNode")]),e._v(", and "),n("code",[e._v("Element.appendChild")]),e._v(". First to create element, second to set attributes, third to deal with text, and fourth to attach any child into parent. You'll see "),n("code",[e._v("$")]),e._v(" notation throughout the codes - variables with "),n("code",[e._v("$")]),e._v(" represent DOM nodes.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const renderer = node => {\n  const { tagName, text, attrs, children } = node;\n  const $elem = document.createElement(tagName);\n\n  for (const attr in attrs) {\n    $elem.setAttribute(attr, attrs[attr]);\n  }\n\n  if (text) {\n    const $text = document.createTextNode(text);\n    $elem.appendChild($text);\n  }\n\n  if (children && children.length > 0) {\n    for (const child of children) {\n      const $child = renderer(child);\n      $elem.appendChild($child);\n    }\n  }\n\n  return $elem;\n};\n")])])]),n("p",[e._v("Observations:")]),e._v(" "),n("ol",[n("li",[e._v("The "),n("code",[e._v("tagName")]),e._v(" that we have in virtual DOM is rendered using "),n("code",[e._v("document.createElement")]),e._v(".")]),e._v(" "),n("li",[e._v("Each "),n("code",[e._v("attrs")]),e._v(" is iterated and is set onto that newly-created-element.")]),e._v(" "),n("li",[e._v("If there is a text, we create and append it into that element.")]),e._v(" "),n("li",[e._v("If our virtual DOM contains children, it goes through each child and "),n("em",[e._v("recursively")]),e._v(" run renderer function on each element (if the children have children, they will go through the same recursion, and so on, until no children is found). The children is appended into the original element.")])]),e._v(" "),n("p",[e._v("Now that we have DOM nodes created, attributes and text appended, and children rendered and appended - these DOM nodes can't wait to be attached into our HTML file, so let's mount it!")]),e._v(" "),n("h1",{attrs:{id:"mounting"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#mounting","aria-hidden":"true"}},[e._v("#")]),e._v(" Mounting")]),e._v(" "),n("p",[e._v("Think of mounting as placing our nodes into HTML page. We will use "),n("code",[e._v("document.replaceWith")]),e._v(".")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const mount = ($nodeToReplace, $nodeTarget) => {\n  $nodeTarget.replaceWith($nodeToReplace);\n  return $nodeToReplace;\n};\n")])])]),n("p",[e._v("Now we have all the functions we need. Let's set up some selectors and mount it:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('const app = document.querySelector("#app");\nlet num = 10;\nlet currentVApp = vAppStructure(num); \nlet $vApp = renderer(currentVApp); \nmount($vApp, app);\n')])])]),n("p",[e._v("You can run "),n("code",[e._v("parcel index.html")]),e._v(" (or "),n("code",[e._v("npm run start")]),e._v(") and watch your virtual DOM displayed in HTML! Super cool. You have rendered your own HTML page using pure Javascript with virtual DOM! This is basic virtual DOM and it is powerful. Next we will explore the power of virtual DOM by updating it periodically.")]),e._v(" "),n("h1",{attrs:{id:"updating-the-inefficient-way"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#updating-the-inefficient-way","aria-hidden":"true"}},[e._v("#")]),e._v(" Updating (the inefficient way)")]),e._v(" "),n("p",[e._v("The power of virtual DOM is whenever you update your JS object without needing screen refresh. \nTo demonstrate updating, we will use "),n("code",[e._v("setInterval")]),e._v(" to increase the number per second.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let $rootElem = mount($vApp, app);\nlet newVApp;\n\nsetInterval(() => {\n  num++;\n  newVApp = vAppStructure(num);\n  let $newVApp = renderer(newVApp);\n  $rootElem = mount($newVApp, $rootElem);\n\n  currentVApp = newVApp;\n}, 1000);\n")])])]),n("p",[e._v("Now if you open up devTools and observe the id of "),n("code",[e._v("ul")]),e._v(" element - "),n("em",[e._v("it is now increasing by 1")]),e._v(". Sweet! We have a working, self-updating DOM node. Beautiful!!")]),e._v(" "),n("p",[e._v("Observations:")]),e._v(" "),n("ol",[n("li",[e._v("Note the assignment$rootElem = mount($newVApp, $rootElem). This is necessary because we are mounting the updated DOM nodes with different number and we are replacing the old one with new one each second. Mounting returns the updated DOM nodes, so we are constantly replacing the old one with new one.")]),e._v(" "),n("li",[e._v("There is a problem. Try typing something on input, it gets refreshed each second. This is because the entire DOM is being replaced each second including input. We want to update affected component only without re-rendering the entire DOM.")])]),e._v(" "),n("p",[e._v("Let's do it the right way!")]),e._v(" "),n("h1",{attrs:{id:"updating-the-efficient-way"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#updating-the-efficient-way","aria-hidden":"true"}},[e._v("#")]),e._v(" Updating the efficient way")]),e._v(" "),n("p",[e._v("One of the most popular Frontend library in the world, React, uses virtual DOM. The way React treats virtual DOM is by "),n("a",{attrs:{href:"https://reactjs.org/docs/reconciliation.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("diffing"),n("OutboundLink")],1),e._v(".")]),e._v(" "),n("ol",[n("li",[e._v("React creates virtual DOM of the app and saves a copy.")]),e._v(" "),n("li",[e._v("When a change occurs (say someone updates a state), React compares the previous copy of virtual DOM with recent copy of virtualDOM - it makes a list of all the differences.")]),e._v(" "),n("li",[e._v("React updates the actual DOM based on the differences found.")])]),e._v(" "),n("p",[e._v("We will create a (very) simplified version of diffing.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const diff = (oldVApp, newVApp) => {\n  const patchAttrs = diffAttrs(oldVApp.attrs, newVApp.attrs);\n\n  return $node => {\n    patchAttrs($node);\n    return $node; // important to return $node, because after diffing, we patch($rootElem) and it expects to return some sort of element!\n  };\n};\nexport default diff;\n")])])]),n("p",[e._v("Observations:")]),e._v(" "),n("ol",[n("li",[e._v("It takes old virtual DOM and new virtual DOM as arguments. Beware, since it is simplified, it will not try to find the differences between old and new virtual DOM but it will simply apply the new attributes into the DOM elements.")])]),e._v(" "),n("p",[e._v("The "),n("code",[e._v("diffAttrs")]),e._v(" function looks like this;")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const diffAttrs = (oldAttrs, newAttrs) => {\n  const patches = [];\n\n  for (const attr in newAttrs) {\n    patches.push($node => {\n      $node.setAttribute(attr, newAttrs[attr]);\n      return $node;\n    });\n  }\n\n  for (const attr in oldAttrs) {\n    if (!(attr in newAttrs)) {\n      patches.push($node => {\n        $node.removeAttribute(attr);\n        return $node;\n      });\n    }\n  }\n  return $node => {\n    for (const patch of patches) {\n      patch($node);\n    }\n  };\n};\n")])])]),n("p",[e._v("Observations:")]),e._v(" "),n("ol",[n("li",[e._v("We are only diffing only attributes and not "),n("code",[e._v("text")]),e._v(", "),n("code",[e._v("children")]),e._v(", "),n("code",[e._v("tagName")]),e._v(". For the sake of brevity I skipped them. The logic is similar though.")]),e._v(" "),n("li",[e._v("When iterating through all attributes, each new attribute is set into the element node (so if new one has "),n("code",[e._v('id="my-id-2"')]),e._v("), it will set that new id into the element node.")]),e._v(" "),n("li",[e._v("We check each "),n("code",[e._v("attr")]),e._v(" in "),n("code",[e._v("oldAttrs")]),e._v(". The assumption is if an attribute is found in "),n("code",[e._v("oldAttrs")]),e._v(" that does not exist in "),n("code",[e._v("newAttrs")]),e._v(", that attribute must have gotten removed, so we delete it.")]),e._v(" "),n("li",[e._v("We return a function to perform patch later.")])]),e._v(" "),n("p",[e._v("Our updated setInterval will look like this:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("setInterval(() => {\n num++;\n newVApp = vAppStructure(num);\n\n const patch = diff(currentVApp, newVApp);\n $rootElem = patch($rootElem);\ncurrentVApp = newVApp;\n}, 1000);\n")])])]),n("p",[e._v("Observations:")]),e._v(" "),n("ol",[n("li",[e._v("Instead of remounting the entire updated HTML element per second, we are setting attributes on new DOM nodes. This will not re-render the entire DOM. "),n("code",[e._v("input")]),e._v(" now works as expected.")])]),e._v(" "),n("h1",{attrs:{id:"conclusion"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#conclusion","aria-hidden":"true"}},[e._v("#")]),e._v(" Conclusion")]),e._v(" "),n("p",[e._v("To recap, here is what we learned:")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("Virtual DOM is a plain JS object describing what a DOM should look like, like a blueprint of a house (whereas a DOM is like a house).")])]),e._v(" "),n("li",[n("p",[e._v("Mounting virtual DOM is a process of iterating virtual DOM properties and calling "),n("code",[e._v("setElement")]),e._v(", "),n("code",[e._v("createTextNode")]),e._v(", "),n("code",[e._v("setAttribute")]),e._v(", and "),n("code",[e._v("appendChild")]),e._v(" (there are more APIs needed in more complicated app ).")])]),e._v(" "),n("li",[n("p",[e._v("The best way to update our app is not to replace the entire DOM structure per update (it will force other element to re-render unnecessarily like "),n("code",[e._v("input")]),e._v("), but to go through each attribute in each element and set new attributes. Doing this will not re-render the element.")])])]),e._v(" "),n("p",[e._v("This is far from perfect - it is a simplified representation of what React/ other framework does.")]),e._v(" "),n("p",[e._v("Thanks for reading this. Appreciate you spending your time and reading! If you have any questions, found mistakes, please feel free to drop by comments. Let me know what new thing you learned from this!")]),e._v(" "),n("p",[e._v("Some resources I found helpful:")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"https://www.codecademy.com/articles/react-virtual-dom",target:"_blank",rel:"noopener noreferrer"}},[e._v("React Virtual DOM"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://medium.com/@gethylgeorge/how-virtual-dom-and-diffing-works-in-react-6fc805f9f84e",target:"_blank",rel:"noopener noreferrer"}},[e._v("How Virtual-DOM and diffing works in React"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"http://taligarsiel.com/Projects/howbrowserswork1.htm",target:"_blank",rel:"noopener noreferrer"}},[e._v("How Browsers Work"),n("OutboundLink")],1)])])])},[],!1,null,null,null);t.default=r.exports}}]);